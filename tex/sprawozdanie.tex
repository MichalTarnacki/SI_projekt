\documentclass{article}

\title{Projekt z SI}
\author{Dominik Lau, Mateusz Kowalczyk, Michał Tarnacki}

\usepackage{blindtext}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{color}
\usepackage{amssymb}
\usepackage{esvect}
\usepackage{graphicx}

\graphicspath{ {./obrazy/} }

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\begin{document}

\maketitle

\section{Wstęp}
Celem projektu było określanie chwil na nagraniu, w których osoba bierze wdech i wydech. 
Dokonano oceny jakościowej za pomocą detekcji oddechu na żywo jak i ilościowej (przy wykorzystaniu
dalej wymienionych metryk).

\section{Teoria}
\subsection{SVM}
Pierwszy model, jakim dokonujemy klasyfikacji, jest oparty o SVM. Metoda ta polega na szukaniu optymalnych wag $\boldsymbol{w}, b$.
Następnie będziemy klasyfikować według funkcji maszyny uczącej 
\begin{gather*}
	f(x) = sgn(\boldsymbol{w}^T \boldsymbol{x} + b)
\end{gather*}
jeśli $f$ zwraca 1 to traktujemy to jako jedną z binarnych decyzji (w naszym przypadku np. wdech) a jeśli zwraca -1 to drugą (czyli np. wydech).
$\textbf{x}$ jest wektorem cech.  Znalezienie optymalnych wag będzie polegało na minimalizacji
funkcji kosztu
\begin{gather*}
	J(\boldsymbol{w}) = \frac{1}{2}||\boldsymbol{w}||^2 + \frac{C}{N}\Sigma_x max\{0, 1 - y(\boldsymbol{w}^Tx + b)\}
\end{gather*}
gdzie C jest parametrem uregulowania. Funkcję będziemy minimalizować metodą spadku po gradiencie (wersję wsadową).
\subsection{Ocena modeli}
Dokładność ($accuracy$) definiujemy jako
\begin{gather*}
	accuracy = \frac{\# correct}{\# all}
\end{gather*}

\section{Zbieranie i obróbka danych}
\subsection{Nagrywanie danych oddechowych}
Żeby zapewnić dobre oznaczenie danych, etykietujemy je jeszcze w trakcie nagrywania dźwięku. 
Osoba nagrywana naciska przycisk, żeby zasygnalizować, że przestała brać wdech i zaczyna wydychać 
powietrze lub na odwrót. Pozyskane natężenie przy dalszej obróbce odszumiamy za pomocą dostępnej
w Pythonie biblioteki $noisereduce$.

\subsection{Średnia częstotliwość w czasie}
Pierwotnie przyjętym założeniem było, że podczas wdechu średnia częstotliwość dźwięku jest wyższa niż
gdy osoba wydycha. Z pliku w formacie .wav dla bloków próbek generujemy spektrogramy i obliczamy
średnią ważoną częstotliwość (czyli znacznie redukujemy rozmiar danych tj. $nowy = stary/rozmiar_{bloku}$).
Cechami, na podstawie których
dokonywana byłaby predykcja mogłyby być na przykład $\vec{x} = [\bar{f}(t_0), \bar{f}(t_1), ..., \bar{f}(t_n)]$.
Podejście to jednak jak i pierwotne założenie jest mylne - dla niektórych osób 
dźwięk wydechu jest bowiem wyższy
niż wdechu. Ponadto, stosując to podejście, ograniczylibyśmy się tylko do niektórych typów oddechu (np. 
wdychanie przez nos i wydychanie przez usta).  Biorąc pod uwagę wszystkie wady podejście zostało odrzucone.
\subsection{Dane wejściowe ze spektrogramu}
Innym podejściem jest wzięcie całego spektrogramu (a przynajmniej jego części) jako dane wejściowe do 
modelu.  Podobnie jak ostatnio dzielimy dane na bloki ale tym razem nie liczymy średniej tylko zostawiamy
całą taką klatkę.
Metoda pochodzi od przypuszczenia, że człowiek rozpoznaje i rozróżnia wdech/wydech
na podstawie barwy dźwięku.  Wektor cech ma więc postać $\vec{x} = [I_{f_1}, I_{f_2}, ..., I_{f_n}]$.
W dalszej części korzystamy z tego podejścia.
\subsection{Ekstrakcja najistotniejszych częstotliwości}
\subsection{Redukcja szumów}
\subsection{Standaryzacja}

\section{Implementacja modeli}
\subsection{SVM ze spektrogramem}
Naszym pierwszym podejściem był SVM, w którym wektor cech stanowił 160 poziomów częstotliwości, 
tj. $\vec{x} = [I_{f_1}, I_{f_2}, ..., I_{f_160}]$.  Na tej podstawie uzyskaliśmy dokładność $\sim 70\%$ dla danych testowych. 
Problemem było jednak, że często zdarzały się sytuacje, w których klasyfikator w połowie wdechu/wydechu "przeskakiwał" 
na chwilę na przeciwną wartość, predykcje te były więc dosyć niestabilne.
\subsection{Informacje o poprzednich stanach}
Model z poprzedniego podpunktu rozszerzyliśmy o informację o wcześniej przewidzianym stanie, czyli 
$\vec{x} = [I_{f_1}, I_{f_2}, ..., I_{f_160},  s]$, gdzie $s = 1$ jeśli poprzednio stwierdzono wdech, $s=-1$ jeśli poprzednio stwierdzono wydech.
Takim podejściem otrzymaliśmy dokładność $\sim 99\%$ dla danych testowych oraz ograniczyliśmy przeskakiwanie przewidywań.

\end{document}
